package com.jr.test.concurrent.practice;

public class LockOptimization {

    /**
     * 锁的使用注意事项：
     * 1.减少锁的持有时间
     * 2.减小锁的粒度
     * 3.读写锁分离
     * 4.分段锁
     * 5.锁粗化
     */

    /**
     * JVM对锁的优化
     *
     * 1.偏向锁：
     * 偏向锁思想认为，在多数情况下，系统对锁的竞争很小，如果一个线程获得了锁，那么他很有可能在很短的将来再次获得锁。
     * 所以在线程获取锁之后，这个锁就进入偏向模式。偏向模式下，JVM会在锁对象的对象头中将此锁标志为偏向锁。
     * 当这个线程再次请求这把锁时，就无需再次进行同步操作。对于几乎没有锁竞争的场合，偏向锁有较好的优化效果。在锁竞争激烈的情况下效果不佳。
     * 当获取偏向锁失败后，偏向锁会膨胀为轻量级锁。
     * 偏向锁在JDK1.6和1.7中是默认开启的，但是需要在JVM启动后一段时间延时后才会生效，使用JVM参数-XX:BiasedLockingStartupDelay=0可以关闭延时。
     * 在1.8中默认偏向锁是关闭的，需要使用JVM参数 -XX:+UseBiasedLocking=true开启。
     *
     * 2.轻量级锁：
     * 偏向锁失败之后，虚拟机不会立即挂起请求锁的线程，而是使用一种轻量级锁的优化手段获取锁。
     *  2.1.轻量级锁加锁
     *  线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，
     *  官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。
     *  如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
     *  2.2.轻量级锁解锁
     *  轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。
     *  如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。轻量级锁的自旋会消耗CPU，所以一旦膨胀到重量级锁，就不会再降级。
     *
     * =======================================================================================
     * 锁的类型 |       优点           |              缺点                   |   适用场景
     * ---------------------------------------------------------------------------------------
     * 偏向锁   | 无额外消耗，性能极高   | 竞争激烈条件下会额外增加锁撤销的消耗    | 竞争很少的情况
     * ---------------------------------------------------------------------------------------
     * 轻量级锁 | 无阻塞，响应快         | 自旋消耗CPU                         | 追求响应时间
     * ---------------------------------------------------------------------------------------
     * 重量级锁 | 无轻量级锁的CPU自旋消耗 | 阻塞，响应时间慢                     | 追求系统吞吐量
     * =======================================================================================
     *
     * 3.自旋锁：
     * 无锁化获取锁，例如CAS自旋
     * CAS自旋的问题：1.ABA问题；2.自旋消耗CPU
     *
     * 4.锁消除：
     * 虽然在代码中显示声明了加解锁操作，但如果实际上不需要加锁，JVM会优化掉
     */

}
