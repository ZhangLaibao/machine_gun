## Optimizing Database Structure

作为数据库设计者，我们需要寻找组织模式，表和列的最有效方法。在调整应用程序代码时，我们可以通过最小化I/O，将相关数据项物理上存储在一起，并提前计划，以便在数据量增加时保持较高的性能。从高效的数据库设计开始，团队成员可以更轻松地编写高性能的应用程序代码，并使数据库可以随着应用程序的发展和重写而持久使用。

### Optimizing Data Size

设计表的一个原则是最小化磁盘空间使用。这可以通过减少写入磁盘和从磁盘读取的数据量来实现巨大的性能提升。较小的表通常需要较少的主内存，而其内容在查询执行期间也能被高效处理。表数据的空间缩减也会使索引文件体积更小，可以更快地处理。

MySQL支持许多不同的存储引擎（表类型）和行存储格式。对于每个表，我们可以选择使用哪种存储和索引方法。为我们的应用程序选择正确的表格式可以带来巨大的性能提升。表设计主要有以下优化方向：

#### Table Columns

• 尽可能使用最有效（最小）的数据类型。MySQL有许多专门的类型可以节省磁盘空间和内存。例如，如果可能，使用较小的整数类型以使表体积更小。MEDIUMINT通常是比INT更好的选择，因为MEDIUMINT列使用的空间减少了25％。

• 尽可能将列声明为NOT NULL。NOT NULL通过更好地使用索引并消除测试每个值是否为NULL的开销，使SQL操作更快。这样还可以节省一些存储空间，每列可以节省1 bit。

#### Row Format

• 默认情况下，InnoDB表使用DYNAMIC行格式。要使用DYNAMIC以外的行格式，需要配置innodb_default_row_format，或在CREATE TABLE或ALTER TABLE语句中显式指定ROW_FORMAT选项。紧凑型行格式系列（包括COMPACT，DYNAMIC和COMPRESSED）减少了行存储空间，但代价是增加了某些操作的CPU使用。如果运行环境的工作负载是受缓存命中率和磁盘速度限制的典型工作负载，则使用紧凑型行格式可能会更快。 如果是受CPU速度限制的罕见情况，则可能会更慢。

当使用可变长度字符集（如utf8mb3或utf8mb4）时，紧凑的行格式系列还可优化CHAR类型列存储。使用ROW_FORMAT = REDUNDANT时，CHAR（N）占用的空间=N×字符集的最大字节长度。许多语言可以使用单字节utf8字符编写，因此固定的存储长度通常会浪费空间。借助紧凑的行格式系列，InnoDB通过去除尾部空格为这些列分配N到N×字符集的最小字节长度范围内的可变数量的存储空间。(The minimum storage length is N bytes to facilitate in-place updates in typical cases)

• 要通过以压缩格式存储表数据来进一步减小空间，可以在创建InnoDB表时指定ROW_FORMAT = COMPRESSED，或在现有MyISAM表上运行myisampack命令。（InnoDB压缩表是可读写的，而MyISAM压缩表是只读的）

• 对于MyISAM表，如果没有任何可变长度列（VARCHAR，TEXT或BLOB列），则使用固定大小的行格式。这样虽然可能浪费一些空间，但是查询效率更高。 即使具有可变长度的VARCHAR列，也可以通过CREATE TABLE选项ROW_FORMAT = FIXED指定我们希望使用固定长度的行。

#### Indexes

• 表的主键索引应尽可能短。这使得主键对行的识别更简单高效。对于InnoDB表，主键列在每个二级索引中被当作扩展，因此如果表有许多二级索引，则短主键可以节省大量空间。

• 仅创建提高查询性能所需的索引。索引适用于检索，但减慢了插入和更新操作。如果应用程序主要通过查询列或几列的方式来访问表，可以在这些列上创建单个复合索引，而不是为每列创建单独的索引。索引的第一部分应该是最常用的列。如果从表中查询时总是使用多列，则索引中的第一列应该是具有最多重复值的列，以获得更好的索引压缩。

• 如果长字符串列很在前几个字符数上差异较大，那么最好只使用列的最左边部分创建索引。较短的索引更快，不仅因为它们需要更少的磁盘空间，而且因为它们还会在索引缓存中为我们提供更多命中，从而减少磁盘搜索次数。 

#### Joins

• 在某些情况下，将一个经常扫描的表分成两个可能是有益的。如果这个表是动态格式表，则尤其如此，并且可以使用较小的静态格式表，该表可用于在扫描表时查找相关行。

• 在具有相同数据类型的不同表中声明具有相同信息的列，以基于这些列加速连接。

• 保持使用简单的列名，以便我们能在不同的表中使用相同的名称并简化连接查询。例如，在名为customer的表中，使用name而不是customer_name。要使表的列名可移植到其他SQL服务器，需要保持为短于18个字符。

#### Normalization

• 通常，尽量减少数据冗余（检查数据库中是否有违背数据库理论第三范式的数据）。不要冗余名称和地址等冗长值，而是为它们分配唯一ID，在多个较小的表中根据需要冗余这些ID，并通过引用join子句中的ID来连接查询中的表。

• 如果相较于磁盘空间和多个数据副本的维护成本，速度更重要，例如在需要分析大型表中的所有数据的商业智能方案中，我们可以放宽规范化规则，适当冗余或创建列汇总表以获得更快的速度。

### Optimizing MySQL Data Types

#### Optimizing for Numeric Data

• 对于唯一ID或其他可以用字符串或数字表示的值，相比字符串类型，首选数字类型。由于存储较大的数值比存储相对应字符串占用更少的字节数，因此传输和比较的速度更快，占用的内存更少。

• 如果使用数字类型数据，则在许多情况下从数据库（使用已有数据库连接）访问信息比访问文本文件更快。数据库中的信息可能以比文本文件更紧凑的格式存储，因此读取数据库涉及到的磁盘空间访问更小。我们还可以在应用程序中节约解析文本文件以查找行和列边界的代码。

#### Optimizing for Character and String Types

对于字符和字符串类型列，遵循以下准则：

• 当不需要基于特定于语言的规则时，推荐使用二进制顺序进行快速比较和操作。我们可以使用BINARY运算符在特定查询中指定使用二进制规则。

• 比较来自不同列的值时，尽可能将他们声明为具有相同字符集和规则的列，以避免在运行查询时进行字符串转换

• 对于大小小于8KB的列值，使用binary VARCHAR而不是BLOB。GROUP BY和ORDER BY子句可以生成临时表，如果原始表不包含任何BLOB列，这些临时表可以使用MEMORY存储引擎。

• 如果表包含使用频率很低的字符串列（如名称和地址），可以考虑将字符串列拆分到单独的表，并在必要时使用外键的连接查询。当MySQL读取整行数据时，它会读取包含该行的所有列（以及可能的其他相邻行）的数据块。仅使用最常用的列可以保持行数据处在较小水平，使每个数据块能容纳更多行数据。这种紧凑的表减少了常见查询的磁盘I/O和内存使用。

• 当使用随机生成的值作为InnoDB表中的主键时，推荐在其前面加上一个升序值，如当前日期和时间。当连续的主键值在物理上存储在一起时，InnoDB可以更快地对他们进行插入和检索。

Optimizing for BLOB Types

#### Optimizing for BLOB Types

• 存储包含文本数据的大blob时，需要考虑先对数据进行压缩。当使用压缩整个表的InnoDB或MyISAM引擎时，不需要使用此技术。

• 对于具有多个列的表，如果查询没有用到BLOB列，可以考虑将BLOB列拆分为单独的表以要减少查询的内存要求，并在需要时使用连接查询引用它。

• 由于检索和显示BLOB类型值的性能要求可能与其他数据类型有很大不同，因此我们可以将使用BLOB的表放在不同的存储设备上，甚至是单独的数据库实例上。例如，要检索BLOB，可能需要更大规模的顺序磁盘读取，这更适合传统硬盘驱动器而不是SSD设备。

• 我们可以将BOLB类型的列值的哈希值存储在单独的列中，索引该列，并在查询中使用哈希值，而不是对非常长的文本字符检查相等性（使用MD5()或CRC32()函数生成哈希值）。由于hash函数可以为不同的输入生成相同的结果，因此在查询中仍然可以包含一个AND Blob_column = long_string_value子句以防止错误的匹配；这样做的性能优势来自较小的，易于扫描的hash值索引。

#### Using PROCEDURE ANALYSE

> ANALYSE([max_elements[,max_memory]])
>
> 从MySQL 5.7.18开始，PROCEDURE ANALYZE()已被弃用，在MySQL 8.0中被删除。

ANALYZE()检查查询的结果，并返回结果分析，该结果为每列建议有助于减小表大小的最佳可能数据类型。要获得此分析结果，需要将PROCEDURE ANALYZE附加到SELECT语句的末尾：

```sql
SELECT ... FROM ... WHERE ... PROCEDURE ANALYSE([max_elements,[max_memory]])
```

例如：

```sql
SELECT col1, col2 FROM table1 PROCEDURE ANALYSE(10, 2000);
```

结果显示了查询结果的一些统计信息，并提供了列的最佳数据类型。这有助于检查现有表或在导入新数据之后进行检查。我们需要为参数尝试不同的设置，以便PROCEDURE ANALYZE()不会推荐不合适的ENUM数据类型。参数是可选的，使用方法如下：

• max_elements(默认值256)是ANALYZE()检查每列不同值的最大数量。ANALYZE()使用它来检查最佳数据类型是否应为ENUM类型；如果有超过max_elements个不同的值，则不会推荐ENUM类型。

• max_memory(默认值8192)是ANALYZE()在尝试查找每列所有不同值时应分配的最大内存量。

UNION语句中不允许使用PROCEDURE子句。

### Optimizing for Many Tables

一些用于优化查询的手段涉及到将包含很多列的大表垂直拆分为多个表。但是当表的数量达到数千甚至数百万时，处理所有这些表的开销成为新的性能考虑因素。

#### How MySQL Opens and Closes Tables

当我们执行mysqladmin status命令时，会看到如下内容：

```sql
Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
```

如果我们只有六个表，那么Open tables: 12可能有点令人费解。MySQL是多线程的，因此可能有许多客户端同时向给定的表发出查询。为了最大限度地减少同一个表上具有不同状态的多个客户端会话的问题，该表由每个并发会话独立打开。这导致额外的内存开销但通常会提高性能。对于MyISAM表，每个打开表的客户端的数据文件都需要一个额外的文件描述符。（相比之下，索引文件描述符在所有会话之间共享）

table_open_cache和max_connections系统变量会影响服务器保持打开的最大文件数。如果增加这些值中的一个或两个，则可能会达到操作系统对每个进程的打开文件描述符数量施加的限制。许多操作系统允许我们提高打开文件数量上限，尽管该方法因系统而异。需要参阅操作系统文档以确定是否可以提高限制以及如何提高限制。

table_open_cache与max_connections有关。例如，对于200个并发连接，表缓存大小至少应为200 * N，其中N是所有查询中连接查询引用的表的最大数量。我们还必须为临时表和文件保留一些额外的文件描述符。

确保我们的操作系统可以处理table_open_cache设置的打开文件描述符的数量。如果table_open_cache设置得太高，MySQL可能会耗尽文件描述符并拒绝连接，无法执行查询，变得非常不可靠。

另外我们还应该考虑到MyISAM存储引擎打开每一个表需要使用两个文件描述符这一事实。对于分区的MyISAM表，打开的表的每个分区都需要两个文件描述符。（进一步，当MyISAM打开分区表时，它会打开此表的每个分区，无论是否实际使用该分区）我们可以使用mysqld的--open-files-limit启动选项增加MySQL可用的文件描述符数。

打开表的缓存被保持在table_open_cache数目的水平。服务器在启动时会自动调整缓存大小。要显式设置大小，需要在启动时设置table_open_cache系统变量。注意，MySQL可能会暂时打开比此数量更多的表来执行查询。

在以下情况下，MySQL会关闭一个未使用的表并将其从表缓存中移除：

• 当缓存已满并且某个线程尝试打开缓存中不存在的表时

• 当缓存包含表的数量超过table_open_cache，并且没有线程使用缓存中的某些表

• 当table flush操作发生时。当有人发送FLUSH TABLES语句或执行mysqladmin flush-tables或mysqladmin refresh命令时

当表缓存填满时，服务器使用以下步骤来查找要使用的缓存条目：

• 从最近最少使用的表开始，释放当前未使用的表。

• 如果需要打开新表，但缓存已满且没有表可以被释放，则会根据需要临时扩展缓存。当缓存处于临时扩展状态并且有表从使用状态变为未使用状态时，表将被关闭并从缓存中释放。

为每个并发访问都会打开一个MyISAM表。这意味着如果两个线程访问同一个表，或者一个线程在同一个查询中访问该表两次（例如，通过自连接），则需要将表打开两次。每个并发访问打开表都需要在表缓存中缓存表。 任何MyISAM表的第一次打开都需要两个文件描述符：一个用于数据文件，另一个用于索引文件。对表的每次额外使用仅为数据文件提供一个文件描述符。索引文件描述符在所有线程之间共享。

如果使用HANDLER tbl_name OPEN语句打开表，则MySQL服务会为该线程分配专用的表对象。此表对象不和其他线程共享，并且直到线程调用HANDLER tbl_name CLOSE或线程终止时才会关闭。发生这种情况时，表将被放回表缓存中（如果缓存未满）。

我们可以通过检查mysql状态变量Opened_tables来确定表缓存设置值是否太小，该变量表示自服务器启动以来的表打开操作数目：

```sql
mysql> SHOW GLOBAL STATUS LIKE 'Opened_tables';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 109   |
+---------------+-------+
```

如果我们没有发送许多FLUSH TABLES语句，但是此值非常大或增长很快，此时需要增加表缓存大小。

#### Disadvantages of Creating Many Tables in the Same Database

如果在同一数据库目录中创建许多MyISAM表，则打开，关闭和创建操作很慢。如果在许多不同的表上执行SELECT语句，在表缓存已满的情况下会产生一些额外开销，因为对于每个必须打开的新表，必须关闭另一个表。
我们可以通过增加表缓存中允许的数量来减少此开销。

### Internal Temporary Table Use in MySQL

在某些情况下，服务器在处理语句时需要创建内部临时表。 用户无法直接控制何时发生这种情况。服务器在以下条件下会创建临时表：

• 处理UNION语句，稍后描述的一些情况除外

• 评估某些视图，例如使用TEMPTABLE算法，UNION或聚合函数的视图

• 处理派生表（FROM子句中的子查询）

• 为子查询或半连接实体化创建的表

• 处理包含ORDER BY子句和GROUP BY子句但是使用不同列的语句，或者ORDER BY或GROUP BY使用了连接队列中第一个表以外的表中的列的语句

• 处理DISTINCT结合ORDER BY的语句可能需要临时表

• 对于使用SQL_SMALL_RESULT修饰符的查询，MySQL使用内存中的临时表，除非查询还包含需要磁盘存储的元素

• 处理从同一个表中选择和插入的INSERT ... SELECT语句，MySQL会创建一个内部临时表来保存SELECT中的行，然后将这些行插入到目标表中

• 处理多表UPDATE语句

• 处理GROUP_CONCAT()或者COUNT(DISTINCT)语句

要确定语句是否需要临时表，使用EXPLAIN并检查Extra列以查看是否显示Using temporary。使用来派生或临时表实体化时，EXPLAIN不一定会显示此结果。

当服务器创建内部临时表（无论是在内存还是磁盘上）时，它会增加Created_tmp_tables状态变量。如果服务器在磁盘上创建表（无论一开始就在磁盘创建还是通过将内存表转换到磁盘），则会增加Created_tmp_disk_tables状态变量。

某些查询条件会阻止在内存中创建临时表，在这些情况下，服务器会在磁盘上创建临时表：

• 表中存在BLOB或TEXT列。包括具有字符串值的用户定义数据类型，因为它们被视为BLOB或TEXT列，具体分别是取决于它们的值是二进制字符串还是非二进制字符串

• 当SELECT列表中存在最大长度大于512的字符串列（二进制字符串的字节数，非二进制字符串的字符数）时，如果使用了UNION或UNION ALL

• SHOW COLUMNS和DESCRIBE语句使用BLOB作为某些列的类型，因此用于结果的临时表是磁盘上的表

服务器不会对满足某些限定条件的UNION语句使用临时表。相反，它仅从临时表创建中保留执行结果列类型转换所必需的数据结构。临时表未完全实例化，并且没有写入或读取行；行数据直接发送到客户端。结果是减少了内存和磁盘要求，并且在将第一行结果发送到客户端之前的延迟较小，因为服务器不需要等到最后一个查询块执行完毕。EXPLAIN和优化程序跟踪输出反映了此执行策略：UNION RESULT查询块不存在，因为该块对应于从临时表中读取的部分。

以下条件使UNION语句不需要临时表即可进行解析：

• union操作是UNION ALL，而不是UNION或UNION DISTINCT

• 没有全局ORDER BY子句

• union不是{INSERT | REPLACE} ... SELECT ...语句的顶级查询块

#### Internal Temporary Table Storage Engine

内部临时表可以保存在内存中，由MEMORY存储引擎处理，或由InnoDB或MyISAM存储引擎存储在磁盘上。如果内部临时表最初在内存中创建但在使用过程中变得太大，MySQL会自动将其转换为磁盘表。内存临时表的最大大小由tmp_table_size和max_heap_table_size中较小的值确定。这与使用CREATE TABLE显式创建的MEMORY表不同：对于此类表，只有max_heap_table_size系统变量确定允许内存表的大小上限s，并且不会转换为磁盘格式。

internal_tmp_disk_storage_engine系统变量确定服务器用于管理磁盘内部临时表的存储引擎。允许的值是INNODB（默认值）和MYISAM。

> 使用internal_tmp_disk_storage_engine = INNODB时，生成超过InnoDB行或列限制的磁盘内部临时表的查询会返回Row size too large或Too many columns错误。解决方法是将internal_tmp_disk_storage_engine设置为MYISAM。

#### Internal Temporary Table Storage Format

内存临时表由MEMORY存储引擎管理，该引擎使用固定长度的行格式。VARCHAR和VARBINARY类型列值会被填充到最大列长度，实际上将它们存储为CHAR和BINARY类型列。

磁盘上的临时表由InnoDB或MyISAM存储引擎管理（取决于internal_tmp_disk_storage_engine设置）。两个引擎都使用动态长度行格式存储临时表。列只占用所需的存储空间，与使用固定长度行的磁盘表相比，这可以减少磁盘I/O和空间要求以及处理时间。

对于最初需要在内存中创建内部临时表，然后将其转换为磁盘表的查询语句，可以通过跳过转换步骤并直接在磁盘上创建表来实现更好的性能。big_tables系统变量可用于强制内部临时表使用磁盘存储。